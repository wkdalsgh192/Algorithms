# 모험가 길드
<이것이 취업을 위한 코딩테스트다, 311p, 나동빈, 한빛미디어>

# 나의 접근
## 풀이 방식
1. 내림차순으로 정렬한다
2. 순회하면서 각각의 인덱스로부터 그룹 만들기를 시작한다.
3. 각 인덱스에 대해 그룹 만들기가 끝나면 최대값을 비교해 갱신한다.
4. 각각의 그룹은 인덱스를 옮겨가며 카운팅한다.

## 문제점
for-loop 내에서 while 문이 또 돌기때문에, 효율성이 떨어진다. O(N*N)

# 올바른 접근
내림차순으로 정렬해, 1씩 카운팅을 하고, 공포값과 같으면 그룹짓는다.

## 놓친 사항
그리디에서는 오름차순으로 정렬할 지, 내림차순으로 정렬할 지를 결정하는 것이 굉장히 중요하다.
**내림차순 정렬후, 그룹을 만든다** 는 아이디어가 핵심!

# 만들 수 없는 금액
<이것이 취업을 위한 코딩테스트다, 314p, 나동빈, 한빛미디어>

## 나의 접근
### 풀이 방식
1. 내림차순으로 정렬한다.
2. 각각의 원소를 이용해 만들 수 있는 수를 모두 셋에 저장한다.
3. 1부터 시작해 1씩 더하면서 값이 셋에 있는 지 확인한다.

### 문제점
이중 for-loop가 돌기 때문에 효율성이 떨어진다. O(N*N)

## 효율성을 위한 접근
### 풀이 방식
1. 화폐 단위를 기준으로 오름차순 정렬한다.
2. 1부터 target을 정하고, 화폐들을 이용해 만들 수 있는 지 확인한다.
3. 만들 수 있으면 다음 타겟값으로 업데이트한다. 
4. 만들 수 없는 케이스를 반환한다.

### 놓친 사항
특정 요소 n(단, n >= 1)을 포함하는 경우, 조합해서 만들 수 있는 최대값은 타겟 + n 이다.

# 볼링공 고르기
<이것이 취업을 위한 코딩테스트다, 315p, 나동빈, 한빛미디어>

## 나의 접근
### 풀이 방식
1. 오름차순으로 정렬한다.
2. 가능한 조합의 수를 구한다.
3. 하나씩 올라가며 같은 무게의 공 갯수를 카운트한다.
4. 더 이상 같은 숫자가 나오지 않으면 해당 경우의 수에서 나올 수 있는 조합을 구해 뺀다. (같은 무게의 공을 선택하는 경우의 수를 뺀다.)

### 문제점
한 번의 for-loop으로 해결하려고 하니까 내부적으로 거쳐야하는 조건문이 많다. (효율성에는 문제가 없지만, 실수가 나왔다.)

## 답안의 접근
### 풀이 방식
1. M 개의 무게를 담을 수 있는 리스트를 만든다.
2. 갯수를 카운트한다.
3. 무게가 담긴 리스트를 순회하면서 A가 선택할 수 있는 공의 갯수를 구한다.
4. 그러고 남은 공의 갯수는 B가 선택할 수 있는 공의 갯수이므로 둘을 곱해 가능한 조합의 수를 더한다.

### 개선점
**무게가 제한적으로 정해져있기 때문에, 하나의 리스트**를 사용할 수 있다.